r"""
使用指南 / Usage Guide:

此脚本用于生成多期锁单数据的对比报告。
它基于 `/Users/zihao_/Documents/coding/dataset/scripts/lock_summary.py` 生成的 Markdown 报告文件进行汇总和对比。
This script generates a comparison report for lock order data across multiple periods.
It summarizes and compares Markdown report files generated by `/Users/zihao_/Documents/coding/dataset/scripts/lock_summary.py`.

用法 / Usage:
    python scripts/generate_comparison_md.py [FILE1] [FILE2] [FILE3] [FILE4] [--output OUTPUT_PATH]

参数 / Arguments:
    files: 需对比的四个锁单总结报告路径 (按时间顺序: 2023-12, 2024-12, 2025-11, 2025-12)
           Paths to four lock summary reports to compare (in chronological order).
    --output: 输出文件路径 (默认: processed/analysis_results/lock_summary_comparison_2023_2025.md)

示例 / Example:
    python scripts/generate_comparison_md.py \
        processed/analysis_results/lock_summary_2023-12-01_to_2023-12-14.md \
        processed/analysis_results/lock_summary_2024-12-01_to_2024-12-14.md \
        processed/analysis_results/lock_summary_2025-11-01_to_2025-11-14.md \
        processed/analysis_results/lock_summary_2025-12-01_to_2025-12-14.md
"""
import argparse
import re
import pandas as pd
from pathlib import Path
from typing import List, Dict, Tuple, Optional

def parse_markdown_table(lines: List[str], start_marker: str, end_marker: Optional[str] = None) -> Optional[pd.DataFrame]:
    # Find start
    start_idx = -1
    for i, line in enumerate(lines):
        if start_marker in line:
            start_idx = i
            break
    
    if start_idx == -1:
        return None
        
    # Collect table lines
    table_lines = []
    for i in range(start_idx + 1, len(lines)):
        line = lines[i].strip()
        if not line:
            continue
        if line.startswith("## ") or (end_marker and end_marker in line):
            break
        if line.startswith("|"):
            table_lines.append(line)
            
    if not table_lines:
        return None
        
    # Parse table
    # Remove header separator line (contains ---)
    table_lines = [l for l in table_lines if not set(l.strip().replace('|', '').replace(':', '').replace('-', '').replace(' ', '')) == set()]
    
    if not table_lines:
        return None

    # Helper to split pipe table
    def split_row(row):
        return [c.strip() for c in row.strip().strip('|').split('|')]

    header = split_row(table_lines[0])
    data = [split_row(l) for l in table_lines[1:]]
    
    df = pd.DataFrame(data, columns=header)
    return df

def get_value_from_line(lines: List[str], pattern: str) -> Optional[str]:
    for line in lines:
        m = re.search(pattern, line)
        if m:
            return m.group(1)
    return None

def extract_file_data(file_path: str):
    with open(file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
        
    data = {}
    
    # 1. Age Stats
    data['age_mean'] = get_value_from_line(lines, r"平均值[:：]\s*([\d.]+)")
    
    # 2. Gender
    gender_df = parse_markdown_table(lines, "## 分性别的锁单量与占比")
    if gender_df is not None:
        # Assuming format: | gender | lock_orders | share_pct |
        # Need to find rows for 男 and 女
        male_row = gender_df[gender_df['gender'].str.contains('男')]
        female_row = gender_df[gender_df['gender'].str.contains('女')]
        
        male_pct = male_row['share_pct'].values[0] if not male_row.empty else "0"
        female_pct = female_row['share_pct'].values[0] if not female_row.empty else "0"
        data['gender_ratio'] = f"{male_pct}% / {female_pct}%"
    else:
        data['gender_ratio'] = "N/A"

    # 3. Age Distribution (Overall)
    # Look for the table WITHOUT (分车型占比%)
    # We can search for "## 分年龄段的锁单量与占比" and check the next line is NOT header with model names
    # Or just use the first occurrence, as our script puts overall first.
    age_df = parse_markdown_table(lines, "## 分年龄段的锁单量与占比", end_marker="## 分年龄段的锁单量与占比（分车型占比%）")
    if age_df is not None:
        # | age_group | lock_orders | share_pct |
        # Convert to dict: age_group -> share_pct
        age_dist = {}
        for _, row in age_df.iterrows():
            age_dist[row['age_group']] = row['share_pct']
        data['age_dist'] = age_dist
    else:
        data['age_dist'] = {}

    # 3.1 Age Distribution (By Model)
    # "## 分年龄段的锁单量与占比（分车型占比%）"
    age_model_df = parse_markdown_table(lines, "## 分年龄段的锁单量与占比（分车型占比%）")
    data['age_model_df'] = age_model_df

    # 4. Region x Model Matrix (Counts)
    # "## 区域 x 车型矩阵"
    region_counts_df = parse_markdown_table(lines, "## 区域 x 车型矩阵")
    data['region_counts_df'] = region_counts_df
    
    # 5. Region Share (Pct)
    # "## 分 region 占比（%）（按车型列归一化）"
    region_pct_df = parse_markdown_table(lines, "## 分 region 占比") # fuzzy match
    data['region_pct_df'] = region_pct_df
    
    return data

def main():
    parser = argparse.ArgumentParser(
        description="生成多期锁单数据对比报告 / Generate Comparison Report",
        epilog="注意：此脚本依赖于 scripts/lock_summary.py 生成的 Markdown 报告作为输入。"
    )
    parser.add_argument("files", nargs=4, help="四个锁单总结报告路径 (按时间顺序: 2023-12, 2024-12, 2025-11, 2025-12)")
    parser.add_argument("--output", default="processed/analysis_results/lock_summary_comparison_2023_2025.md")
    args = parser.parse_args()
    
    files = args.files
    labels = ["2023-12", "2024-12", "2025-11", "2025-12"]
    
    all_data = []
    for f in files:
        all_data.append(extract_file_data(f))
        
    # --- Generate Report ---
    lines = []
    lines.append("# 锁单数据多期对比报告")
    lines.append("")
    
    # 1. Core Metrics
    lines.append("## 1. 核心指标对比（锁单总数、年龄均值、性别比例）")
    lines.append("")
    lines.append(f"| 指标 | {labels[0]} (CM0) | {labels[1]} (CM1) | {labels[2]} (CM2 系列) | {labels[3]} (CM2 系列) |")
    lines.append("| :--- | :--- | :--- | :--- | :--- |")
    
    # Calculate totals and breakdowns
    totals_row = "| **锁单总数** |"
    for d in all_data:
        if d['region_counts_df'] is not None:
            df = d['region_counts_df']
            # Convert columns to numeric
            cols = [c for c in df.columns if c != "Parent Region Name"]
            for c in cols:
                df[c] = pd.to_numeric(df[c].astype(str).str.replace(',', ''), errors='coerce').fillna(0)
            
            total = int(df[cols].sum().sum())
            
            # Breakdown
            breakdown = []
            if "CM0" in cols:
                breakdown.append(f"CM0: {int(df['CM0'].sum())}")
            if "CM1" in cols:
                breakdown.append(f"CM1: {int(df['CM1'].sum())}")
            if "CM2" in cols:
                breakdown.append(f"CM2: {int(df['CM2'].sum())}")
            if "CM2 增程" in cols:
                breakdown.append(f"增程: {int(df['CM2 增程'].sum())}")
            
            breakdown_str = ", ".join(breakdown)
            if breakdown_str:
                cell = f"**{total}** ({breakdown_str})"
            else:
                cell = f"**{total}**"
            
            totals_row += f" {cell} |"
        else:
            totals_row += " N/A |"
    lines.append(totals_row)
    
    # Age Mean
    mean_row = "| **车主年龄平均值** |"
    for d in all_data:
        mean_row += f" {d.get('age_mean', 'N/A')} |"
    lines.append(mean_row)
    
    # Gender
    gender_row = "| **分性别锁单比例 (男/女)** |"
    for d in all_data:
        gender_row += f" {d.get('gender_ratio', 'N/A')} |"
    lines.append(gender_row)
    
    lines.append("")
    
    # 2. Age Distribution
    lines.append("## 2. 车主年龄分布对比（占比 %）")
    lines.append("")
    
    header = "| 年龄段 | 23-12 (CM0) | 24-12 (CM1) | 25-11 (CM2) | 25-11 (CM2 增程) | 25-12 (CM2) | 25-12 (CM2 增程) |"
    lines.append(header)
    lines.append("| :--- | :--- | :--- | :--- | :--- | :--- | :--- |")
    
    age_groups = ["00后", "95后", "90后", "85后", "80后", "75后", "70后", "70前"]
    for grp in age_groups:
        # Helper to get val
        def get_age_pct(idx, col):
            df = all_data[idx]['age_model_df']
            if df is not None and col in df.columns:
                row = df[df['age_group'] == grp]
                if not row.empty:
                    return row[col].values[0]
            # Fallback for CM1 in 24-12 if table not found but overall exists?
            # Actually, we verified the table exists in all 3 files now.
            return "0"
            
        p0 = get_age_pct(0, "CM0")
        p1 = get_age_pct(1, "CM1")
        p2a = get_age_pct(2, "CM2")
        p2b = get_age_pct(2, "CM2 增程")
        p3a = get_age_pct(3, "CM2")
        p3b = get_age_pct(3, "CM2 增程")
        
        line = f"| **{grp}** | {p0} | {p1} | {p2a} | {p2b} | {p3a} | {p3b} |"
        lines.append(line)
        
    lines.append("")
    
    # 3. Region x Model Matrix
    lines.append("## 3. 区域 x 车型矩阵（锁单量）")
    lines.append("")
    
    header = "| 区域 | 23-12 (CM0) | 24-12 (CM1) | 25-11 (CM2) | 25-11 (CM2 增程) | 25-12 (CM2) | 25-12 (CM2 增程) |"
    lines.append(header)
    lines.append("| :--- | :--- | :--- | :--- | :--- | :--- | :--- |")
    
    # Get union of regions
    regions = set()
    for d in all_data:
        if d['region_counts_df'] is not None:
            regions.update(d['region_counts_df']['Parent Region Name'].values)
    
    # Build a consolidated DF for sorting
    rows_data = []
    for reg in regions:
        row_vals = {'Region': reg, 'Total': 0}
        
        # 23-12 CM0
        df0 = all_data[0]['region_counts_df']
        val0 = 0
        if df0 is not None and "CM0" in df0.columns:
            r = df0[df0['Parent Region Name'] == reg]
            if not r.empty:
                val0 = int(pd.to_numeric(r["CM0"], errors='coerce').fillna(0).values[0])
        row_vals['c0'] = val0
        row_vals['Total'] += val0

        # 24-12 CM1
        df1 = all_data[1]['region_counts_df']
        val1 = 0
        if df1 is not None and "CM1" in df1.columns:
            r = df1[df1['Parent Region Name'] == reg]
            if not r.empty:
                val1 = int(pd.to_numeric(r["CM1"], errors='coerce').fillna(0).values[0])
        row_vals['c1'] = val1
        row_vals['Total'] += val1
        
        # 25-11 CM2/增程
        df2 = all_data[2]['region_counts_df']
        val2a, val2b = 0, 0
        if df2 is not None:
            r = df2[df2['Parent Region Name'] == reg]
            if not r.empty:
                if "CM2" in df2.columns:
                    val2a = int(pd.to_numeric(r["CM2"], errors='coerce').fillna(0).values[0])
                if "CM2 增程" in df2.columns:
                    val2b = int(pd.to_numeric(r["CM2 增程"], errors='coerce').fillna(0).values[0])
        row_vals['c2a'] = val2a
        row_vals['c2b'] = val2b
        row_vals['Total'] += val2a + val2b
        
        # 25-12 CM2/增程
        df3 = all_data[3]['region_counts_df']
        val3a, val3b = 0, 0
        if df3 is not None:
            r = df3[df3['Parent Region Name'] == reg]
            if not r.empty:
                if "CM2" in df3.columns:
                    val3a = int(pd.to_numeric(r["CM2"], errors='coerce').fillna(0).values[0])
                if "CM2 增程" in df3.columns:
                    val3b = int(pd.to_numeric(r["CM2 增程"], errors='coerce').fillna(0).values[0])
        row_vals['c3a'] = val3a
        row_vals['c3b'] = val3b
        row_vals['Total'] += val3a + val3b
        
        rows_data.append(row_vals)
        
    # Sort by Total Descending
    rows_data.sort(key=lambda x: x['Total'], reverse=True)
    
    for r in rows_data:
        line = f"| **{r['Region']}** | {r['c0']} | {r['c1']} | {r['c2a']} | {r['c2b']} | {r['c3a']} | {r['c3b']} |"
        lines.append(line)
        
    lines.append("")
    
    # 4. Region Share
    lines.append("## 4. 分 Region 占比（%）（按车型列归一化）")
    lines.append("")
    lines.append(header) # Same header structure
    lines.append("| :--- | :--- | :--- | :--- | :--- | :--- | :--- |")
    
    # Re-use rows_data structure but fetch from pct_df
    # Note: Pct DF values are strings "12.34"
    
    for r_data in rows_data: # Use same order as above
        reg = r_data['Region']
        
        # Helper to get val
        def get_pct(idx, col):
            df = all_data[idx]['region_pct_df']
            if df is not None and col in df.columns:
                row = df[df['Parent Region Name'] == reg]
                if not row.empty:
                    return row[col].values[0]
            return "0"
            
        p0 = get_pct(0, "CM0")
        p1 = get_pct(1, "CM1")
        p2a = get_pct(2, "CM2")
        p2b = get_pct(2, "CM2 增程")
        p3a = get_pct(3, "CM2")
        p3b = get_pct(3, "CM2 增程")
        
        line = f"| **{reg}** | {p0} | {p1} | {p2a} | {p2b} | {p3a} | {p3b} |"
        lines.append(line)
        
    # Write output
    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    with open(out_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(lines))
        
    print(f"Comparison report saved to: {out_path}")

if __name__ == "__main__":
    main()
